use serde::{Deserialize, Serialize};

use crate::{params::TimeSignature, tuning::TuningParams};

// --- RHYTHM MODE (Strategy Pattern) ---

#[derive(Clone, Copy, Debug, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum RhythmMode {
    #[default]
    Euclidean, // Algorithme de Bjorklund (Classique)
    PerfectBalance, // Algorithme Additif (XronoMorph style) - Polygones réguliers
    ClassicGroove,  // Patterns de batterie réalistes (ghost notes, grooves)
}

/// Événement déclenché à chaque step du séquenceur
/// Indique quelles voix doivent jouer
#[derive(Clone, Copy, Debug, Default)]
pub struct StepTrigger {
    pub kick: bool,    // Fondation (Square/Octagon)
    pub snare: bool,   // Tension (Triangle/Backbeat)
    pub hat: bool,     // Remplissage (Euclidean Fills)
    pub bass: bool,    // NEW: Harmonie Basse (Channel 0)
    pub lead: bool,    // NEW: Mélodie (Channel 1)
    pub velocity: f32, // Dynamique générale (0.0 à 1.0)
}

impl StepTrigger {
    #[must_use]
    pub const fn is_any(&self) -> bool {
        self.kick || self.snare || self.hat || self.bass || self.lead
    }
}

// --- POLYGON (Perfect Balance Primitive) ---

/// Represents a regular polygon inscribed in the time cycle.
/// This is the atomic unit of the "Perfect Balance" algorithm.
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct Polygon {
    /// Number of vertices (e.g., 3 = Triangle, 4 = Square).
    /// Ideally should be a divisor of the total steps for perfect alignment.
    pub vertices: usize,

    /// Rotation in steps (Phase shift).
    /// Determines where the polygon starts on the circle.
    pub rotation_offset: usize,

    /// Velocity (Amplitude) of events generated by this polygon.
    pub velocity: f32,
}

impl Polygon {
    /// Standard constructor
    #[must_use]
    pub const fn new(vertices: usize, rotation_offset: usize, velocity: f32) -> Self {
        Self { vertices, rotation_offset, velocity }
    }

    /// Checks if this polygon has an active vertex at the given step.
    /// Uses a fast path when `total_steps` is divisible by vertices,
    /// and falls back to a Euclidean rhythm algorithm for non-divisible cases.
    #[must_use]
    pub const fn hits(&self, step: usize, total_steps: usize) -> bool {
        if self.vertices == 0 || total_steps == 0 {
            return false;
        }
        // If vertices are more than total_steps, it's not meaningful to have hits in a polygon context.
        // This also prevents the Euclidean algorithm from always returning true.
        if self.vertices > total_steps {
            return false;
        }

        let adjusted_step =
            (step + total_steps - (self.rotation_offset % total_steps)) % total_steps;

        if total_steps.is_multiple_of(self.vertices) {
            // Fast path for when vertices is a divisor of total_steps.
            let interval = total_steps / self.vertices;
            // interval cannot be 0 here because we already checked self.vertices > total_steps
            // and total_steps is not 0.
            adjusted_step.is_multiple_of(interval)
        } else {
            // Fallback for non-divisors, generates a Euclidean rhythm.
            let prev_adjusted_step = (adjusted_step + total_steps - 1) % total_steps;
            (adjusted_step * self.vertices) / total_steps
                != (prev_adjusted_step * self.vertices) / total_steps
        }
    }
}

// --- SEQUENCER STRUCT ---

#[derive(Clone)]
pub struct Sequencer {
    /// Time signature (NEW: explicit instead of inferred)
    pub time_signature: TimeSignature,

    /// Steps per quarter note (subdivision resolution)
    pub steps_per_quarter: usize,

    /// DEPRECATED: Use steps_per_measure() instead
    /// Kept for backward compatibility during migration
    pub steps: usize,

    pub pulses: usize,
    pub pattern: Vec<StepTrigger>, // Remplacement de Vec<bool>
    pub rotation: usize,

    /// Current step within measure (0-indexed)
    pub current_step: usize,

    /// Current measure number (1-indexed)
    pub current_measure: usize,

    pub bpm: f32,
    pub last_tick_time: f64,
    pub mode: RhythmMode,
    pub tension: f32,
    pub density: f32,
    /// Optional tuning parameters for configurable rhythm generation
    tuning: Option<TuningParams>,
}

impl Sequencer {
    /// NEW: Create sequencer with explicit time signature
    #[must_use]
    pub fn new_with_time_sig(
        time_sig: TimeSignature,
        steps_per_quarter: usize,
        pulses: usize,
        bpm: f32,
        mode: RhythmMode,
    ) -> Self {
        let steps_per_measure = time_sig.steps_per_measure(steps_per_quarter);
        let mut seq = Self {
            time_signature: time_sig,
            steps_per_quarter,
            steps: steps_per_measure, // Deprecated field, kept for compat
            pulses,
            pattern: vec![StepTrigger::default(); steps_per_measure],
            rotation: 0,
            current_step: 0,
            current_measure: 1,
            bpm,
            last_tick_time: 0.0,
            mode,
            tension: 0.0,
            density: 0.5,
            tuning: None,
        };
        seq.regenerate_pattern();
        seq
    }

    /// DEPRECATED: Legacy constructor for backward compatibility
    /// Use new_with_time_sig() for new code
    #[must_use]
    pub fn new(steps: usize, pulses: usize, bpm: f32) -> Self {
        Self::new_with_mode(steps, pulses, bpm, RhythmMode::Euclidean)
    }

    /// DEPRECATED: Legacy constructor for backward compatibility
    #[must_use]
    pub fn new_with_mode(steps: usize, pulses: usize, bpm: f32, mode: RhythmMode) -> Self {
        // Infer time signature from steps (legacy behavior)
        let time_signature = match steps {
            12 => TimeSignature::THREE_FOUR,
            24 => TimeSignature::SIX_EIGHT,
            _ => TimeSignature::FOUR_FOUR,
        };
        let steps_per_quarter = match steps {
            12 | 16 | 24 => 4,
            48 => 12,
            96 => 24,
            192 => 48,
            _ => 4,
        };

        let mut seq = Self {
            time_signature,
            steps_per_quarter,
            steps,
            pulses,
            pattern: vec![StepTrigger::default(); steps],
            rotation: 0,
            current_step: 0,
            current_measure: 1,
            bpm,
            last_tick_time: 0.0,
            mode,
            tension: 0.0,
            density: 0.5,
            tuning: None,
        };
        seq.regenerate_pattern();
        seq
    }

    /// Create a Sequencer from TuningParams
    ///
    /// This constructor uses the centralized tuning configuration instead of
    /// hardcoded defaults, enabling the LLM tuning loop to adjust rhythm parameters.
    #[must_use]
    pub fn from_tuning(
        steps: usize,
        pulses: usize,
        bpm: f32,
        mode: RhythmMode,
        tuning: &TuningParams,
    ) -> Self {
        // Infer time signature from steps (legacy behavior)
        let time_signature = match steps {
            12 => TimeSignature::THREE_FOUR,
            24 => TimeSignature::SIX_EIGHT,
            _ => TimeSignature::FOUR_FOUR,
        };
        let steps_per_quarter = match steps {
            12 | 16 | 24 => 4,
            48 => 12,
            96 => 24,
            192 => 48,
            _ => 4,
        };

        let mut seq = Self {
            time_signature,
            steps_per_quarter,
            steps,
            pulses,
            pattern: vec![StepTrigger::default(); steps],
            rotation: 0,
            current_step: 0,
            current_measure: 1,
            bpm,
            last_tick_time: 0.0,
            mode,
            tension: 0.0,
            density: 0.5,
            tuning: Some(tuning.clone()),
        };
        seq.regenerate_pattern();
        seq
    }

    /// Get total steps per measure (derived from time signature)
    #[must_use]
    pub fn steps_per_measure(&self) -> usize {
        self.time_signature.steps_per_measure(self.steps_per_quarter)
    }

    /// Get current beat position (1-indexed) and step within beat (0-indexed)
    ///
    /// # Returns
    /// (beat_number, step_in_beat) where beat_number is 1-indexed
    ///
    /// # Example
    /// ```
    /// # use harmonium_core::sequencer::Sequencer;
    /// # use harmonium_core::params::TimeSignature;
    /// # use harmonium_core::sequencer::RhythmMode;
    /// let seq = Sequencer::new_with_time_sig(
    ///     TimeSignature::FOUR_FOUR, 4, 4, 120.0, RhythmMode::Euclidean
    /// );
    /// let (beat, step_in_beat) = seq.current_beat_position();
    /// assert_eq!(beat, 1);  // First beat
    /// assert_eq!(step_in_beat, 0);  // First step in beat
    /// ```
    #[must_use]
    pub fn current_beat_position(&self) -> (usize, usize) {
        let steps_per_beat = self.steps_per_quarter * 4 / self.time_signature.denominator as usize;
        let beat = (self.current_step / steps_per_beat) + 1;
        let step_in_beat = self.current_step % steps_per_beat;
        (beat, step_in_beat)
    }

    #[must_use]
    pub fn new_with_rotation(steps: usize, pulses: usize, bpm: f32, rotation: usize) -> Self {
        let mut seq = Self::new(steps, pulses, bpm);
        seq.set_rotation(rotation);
        seq
    }

    pub fn set_rotation(&mut self, offset: usize) {
        self.rotation = offset % self.steps;
        // On régénère simplement pour appliquer la rotation
        // (Optimisation possible : rotation in-place, mais régénérer est plus sûr ici)
        self.regenerate_pattern();
    }

    pub fn regenerate_pattern(&mut self) {
        let steps_per_measure = self.steps_per_measure();

        let mut raw = match self.mode {
            RhythmMode::Euclidean => {
                // Mode classique : On map le booléen sur Kick + Hat
                let bools = generate_euclidean_bools(steps_per_measure, self.pulses);
                bools
                    .into_iter()
                    .map(|b| StepTrigger {
                        kick: b,
                        snare: false,
                        hat: b,  // Layering simple
                        bass: b, // Sync bass with kick in Euclidean mode
                        lead: false,
                        velocity: if b { 1.0 } else { 0.0 },
                    })
                    .collect()
            }
            RhythmMode::PerfectBalance => {
                // NEW: Use time-signature-aware generation
                generate_balanced_layers_with_time_sig(
                    self.time_signature,
                    steps_per_measure,
                    self.density,
                    self.tension,
                    self.tuning.as_ref(),
                )
            }
            RhythmMode::ClassicGroove => {
                // NEW: Use time-signature-aware generation
                // Falls back to PerfectBalance for non-4/4
                generate_classic_groove_with_time_sig(
                    self.time_signature,
                    steps_per_measure,
                    self.density,
                    self.tension,
                )
            }
        };

        // Appliquer la rotation (safe: handle edge cases)
        let raw_len = raw.len();
        if self.rotation > 0 && raw_len > 0 {
            let safe_rotation = self.rotation % raw_len;
            if safe_rotation > 0 {
                raw.rotate_left(raw_len - safe_rotation);
            }
        }

        self.pattern = raw;
    }

    /// Upgrade to a specific number of steps (48, 96, etc.)
    pub fn upgrade_to_steps(&mut self, new_steps: usize) {
        if self.steps != new_steps && new_steps > 0 {
            self.steps = new_steps;
            self.current_step = 0;
            // Clamp rotation to new step count to prevent overflow in regenerate_pattern
            self.rotation %= new_steps;
            self.pattern = vec![StepTrigger::default(); new_steps];
            self.regenerate_pattern();
        }
    }

    /// Legacy: upgrade to 48 steps
    pub fn upgrade_to_48_steps(&mut self) {
        self.upgrade_to_steps(48);
    }

    pub fn tick(&mut self) -> StepTrigger {
        if self.pattern.is_empty() {
            return StepTrigger::default();
        }
        // Safety: clamp current_step to pattern bounds (can become invalid if steps changed)
        if self.current_step >= self.pattern.len() {
            self.current_step = 0;
        }

        let trigger = self.pattern[self.current_step];

        // Advance position
        self.current_step += 1;
        let steps_in_measure = self.steps_per_measure();
        if self.current_step >= steps_in_measure {
            self.current_step = 0;
            self.current_measure += 1;
        }

        trigger
    }
}

/// Génère les booléens de Bjorklund (Legacy)
#[must_use]
pub fn generate_euclidean_bools(steps: usize, pulses: usize) -> Vec<bool> {
    if pulses == 0 {
        return vec![false; steps];
    }
    if pulses >= steps {
        return vec![true; steps];
    }

    let mut pattern: Vec<Vec<u8>> = Vec::new();
    for _ in 0..pulses {
        pattern.push(vec![1]);
    }
    for _ in 0..(steps - pulses) {
        pattern.push(vec![0]);
    }

    let mut count = std::cmp::min(pulses, steps - pulses);
    let mut remainder = pattern.len() - count;

    while remainder > 1 && count > 0 {
        for i in 0..count {
            if let Some(last) = pattern.pop() {
                pattern[i].extend(last);
            }
        }
        remainder = pattern.len() - count;
        count = std::cmp::min(count, remainder);
    }

    let mut result = Vec::new();
    for group in pattern {
        for val in group {
            result.push(val == 1);
        }
    }
    result
}

// --- ALGORITHME PERFECT BALANCE / WELL-FORMED ---
// Based on XronoMorph theory: superposition of regular polygons
// Density controls polygon complexity (number of vertices)
// Tension controls phase shift (rotation) for syncopation

/// NEW: Generates a pattern with time signature awareness
/// Adapts polygon vertices to the number of beats in the measure
#[must_use]
pub fn generate_balanced_layers_with_time_sig(
    time_sig: TimeSignature,
    steps_per_measure: usize,
    density: f32,
    tension: f32,
    _tuning: Option<&TuningParams>,
) -> Vec<StepTrigger> {
    let mut triggers = vec![StepTrigger::default(); steps_per_measure];

    // Calculate beat subdivisions based on time signature
    let beats_per_measure = time_sig.numerator as usize;
    let steps_per_beat = steps_per_measure / beats_per_measure;

    // --- 1. LAYER CONFIGURATION ---

    // LAYER A: KICK (Foundation) - Adapt to beats per measure
    let kick_gon = if density < 0.3 {
        // Low density: only downbeat
        Polygon::new(1, 0, 1.0)
    } else if density < 0.6 {
        // Medium: all beats (e.g., 3 vertices for 3/4, 4 for 4/4, 5 for 5/4)
        Polygon::new(beats_per_measure, 0, 1.0)
    } else {
        // High: beats + subdivisions
        Polygon::new(beats_per_measure * 2, 0, 1.0)
    };

    // LAYER B: SNARE (Counterpoint) - Time-signature-aware patterns
    let (snare_vertices, snare_base_offset) = match time_sig.numerator {
        3 => (2, steps_per_beat), // 3/4: snare on beat 2 (1 vertex, offset by 1 beat)
        4 => (2, steps_per_beat), // 4/4: snare on beats 2&4 (classic backbeat)
        5 => (2, steps_per_beat), // 5/4: snare on beats 2&4
        6 => (3, steps_per_beat), // 6/8: snare on beats 2,4,6
        7 => (3, steps_per_beat * 2), // 7/8: snare on beats 3,5,7
        _ => (2, steps_per_beat), // Default: backbeat pattern
    };

    // Apply tension as additional rotation
    let max_snare_shift = steps_per_measure / snare_vertices;
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let tension_offset = (tension * max_snare_shift as f32 * 0.5) as usize;
    let snare_offset = snare_base_offset + tension_offset;

    let snare_gon = Polygon::new(snare_vertices, snare_offset, 0.9);

    // LAYER C: HI-HAT (Fill) - Density-based, time-signature agnostic
    let hat_vertices = if density < 0.25 {
        6 // Sparse
    } else if density < 0.6 {
        8 // Medium
    } else if density < 0.85 {
        12 // Dense
    } else {
        16 // Very dense
    };

    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let hat_offset = if tension > 0.3 {
        (tension * (steps_per_measure / hat_vertices) as f32 * 0.5) as usize
    } else {
        0
    };

    let hat_gon = Polygon::new(hat_vertices, hat_offset, 0.6 * density.max(0.5));

    // LAYER D: BASS (Harmonic Foundation)
    let bass_gon = if density < 0.4 { kick_gon } else { Polygon::new(8, 0, 0.8) };

    // LAYER E: LEAD (Melody)
    let lead_vertices = if density < 0.3 { 3 } else { 5 };
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let lead_offset = (tension * (steps_per_measure / lead_vertices) as f32) as usize;
    let lead_gon = Polygon::new(lead_vertices, lead_offset, 0.7);

    // --- 2. RASTERIZATION (Collision Calculation) ---

    for (i, trigger) in triggers.iter_mut().enumerate().take(steps_per_measure) {
        let hit_kick = kick_gon.hits(i, steps_per_measure);
        let hit_snare = snare_gon.hits(i, steps_per_measure);
        let hit_hat = hat_gon.hits(i, steps_per_measure);
        let hit_bass = bass_gon.hits(i, steps_per_measure);
        let hit_lead = lead_gon.hits(i, steps_per_measure);

        // --- 3. CONFLICT RESOLUTION & VELOCITY ---

        if hit_kick {
            trigger.kick = true;
            trigger.velocity = kick_gon.velocity;
        }

        if hit_snare {
            trigger.snare = true;
            trigger.velocity = if hit_kick { 1.0 } else { snare_gon.velocity };
        }

        if hit_hat {
            let mask = (hit_kick || hit_snare) && density < 0.75;
            if !mask {
                trigger.hat = true;
                if !hit_kick && !hit_snare {
                    trigger.velocity = hat_gon.velocity;
                }
            }
        }

        if hit_bass {
            trigger.bass = true;
        }
        if hit_lead {
            trigger.lead = true;
        }
    }

    triggers
}

/// DEPRECATED: Use generate_balanced_layers_with_time_sig() for new code
/// Generates a pattern based on the superposition of regular polygons.
/// Respects the Perfect Balance theorem (sum of vectors is zero).
#[must_use]
pub fn generate_balanced_layers_48(steps: usize, density: f32, tension: f32) -> Vec<StepTrigger> {
    let mut triggers = vec![StepTrigger::default(); steps];

    // --- 1. LAYER CONFIGURATION ---

    // LAYER A: KICK (Foundation)
    // Uses stable (even) shapes
    let kick_gon = if density < 0.3 {
        // Low density: Digon (on 1 and 25 for 48 steps)
        Polygon::new(2, 0, 1.0)
    } else {
        // Standard density: Square (Four-on-the-floor)
        Polygon::new(4, 0, 1.0)
    };

    // LAYER B: SNARE (Counterpoint)
    // Uses odd shapes to create polyrhythm (e.g., 4 against 3)
    // OR shapes shifted by tension.
    let snare_vertices = if density < 0.5 { 3 } else { 6 }; // Triangle or Hexagon

    // Tension controls Snare rotation relative to Kick.
    // Tension 0.0 = Aligned. Tension 0.5 = Pure shift (off-beat).
    // On 48 steps, a full shift = steps / vertices.
    let max_snare_shift = steps / snare_vertices;
    // Using simple casting for integer arithmetic on grid
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let snare_offset = (tension * max_snare_shift as f32) as usize;

    let snare_gon = Polygon::new(snare_vertices, snare_offset, 0.9);

    // LAYER C: HI-HAT (Fill)
    // High frequency shapes.
    let hat_vertices = if density < 0.25 {
        6 // Triplet eighths
    } else if density < 0.6 {
        8 // Straight eighths
    } else if density < 0.85 {
        12 // Sixteenths
    } else {
        16 // Fast polyrhythm (fast 4:3)
    };

    // The Hat often "floats" around the beat to create groove.
    // Use tension to slightly shift the Hat (Mathematical Swing).
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let hat_offset =
        if tension > 0.3 { (tension * (steps / hat_vertices) as f32 * 0.5) as usize } else { 0 };

    let hat_gon = Polygon::new(hat_vertices, hat_offset, 0.6 * density.max(0.5));

    // LAYER D: BASS (Harmonic Foundation)
    let bass_gon = if density < 0.4 { kick_gon } else { Polygon::new(8, 0, 0.8) };

    // LAYER E: LEAD (Melody)
    let lead_vertices = if density < 0.3 { 3 } else { 5 };
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let lead_offset = (tension * (steps / lead_vertices) as f32) as usize;
    let lead_gon = Polygon::new(lead_vertices, lead_offset, 0.7);

    // --- 2. RASTERIZATION (Collision Calculation) ---

    for (i, trigger) in triggers.iter_mut().enumerate().take(steps) {
        let hit_kick = kick_gon.hits(i, steps);
        let hit_snare = snare_gon.hits(i, steps);
        let hit_hat = hat_gon.hits(i, steps);
        let hit_bass = bass_gon.hits(i, steps);
        let hit_lead = lead_gon.hits(i, steps);

        // --- 3. CONFLICT RESOLUTION & VELOCITY ---

        if hit_kick {
            trigger.kick = true;
            trigger.velocity = kick_gon.velocity;
        }

        if hit_snare {
            trigger.snare = true;
            // If snare hits same time as kick, accentuate it
            trigger.velocity = if hit_kick { 1.0 } else { snare_gon.velocity };
        }

        if hit_hat {
            // Masking logic: Don't necessarily play HH if Kick or Snare plays
            // Unless density is very high (Wall of sound)
            let mask = (hit_kick || hit_snare) && density < 0.75;

            if !mask {
                trigger.hat = true;
                // If it's the only element, apply its velocity
                if !hit_kick && !hit_snare {
                    trigger.velocity = hat_gon.velocity;
                }
            }
        }

        if hit_bass {
            trigger.bass = true;
        }
        if hit_lead {
            trigger.lead = true;
        }
    }

    triggers
}

/// Generates a pattern based on the superposition of regular polygons using TuningParams.
/// This version allows the LLM tuning loop to adjust polygon parameters.
#[must_use]
pub fn generate_balanced_layers_with_tuning(
    steps: usize,
    density: f32,
    tension: f32,
    tuning: &TuningParams,
) -> Vec<StepTrigger> {
    let mut triggers = vec![StepTrigger::default(); steps];

    // --- 1. LAYER CONFIGURATION (from TuningParams) ---

    // LAYER A: KICK (Foundation)
    let kick_gon = if density < tuning.kick_density_threshold {
        Polygon::new(tuning.kick_low_density_vertices, 0, 1.0)
    } else {
        Polygon::new(tuning.kick_high_density_vertices, 0, 1.0)
    };

    // LAYER B: SNARE (Counterpoint)
    let snare_vertices = if density < tuning.snare_density_threshold {
        tuning.snare_low_density_vertices
    } else {
        tuning.snare_high_density_vertices
    };

    let max_snare_shift = steps / snare_vertices;
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let snare_offset = (tension * max_snare_shift as f32) as usize;
    let snare_gon = Polygon::new(snare_vertices, snare_offset, 0.9);

    // LAYER C: HI-HAT (Fill) - using density thresholds from tuning
    let hat_vertices = if density < 0.25 {
        tuning.hat_very_low_density_vertices
    } else if density < 0.6 {
        tuning.hat_low_density_vertices
    } else if density < 0.85 {
        tuning.hat_medium_density_vertices
    } else {
        tuning.hat_high_density_vertices
    };

    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let hat_offset =
        if tension > 0.3 { (tension * (steps / hat_vertices) as f32 * 0.5) as usize } else { 0 };
    let hat_gon = Polygon::new(hat_vertices, hat_offset, 0.6 * density.max(0.5));

    // LAYER D: BASS (Harmonic Foundation)
    let bass_gon = if density < 0.4 { kick_gon } else { Polygon::new(8, 0, 0.8) };

    // LAYER E: LEAD (Melody)
    let lead_vertices = if density < 0.3 { 3 } else { 5 };
    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
    let lead_offset = (tension * (steps / lead_vertices) as f32) as usize;
    let lead_gon = Polygon::new(lead_vertices, lead_offset, 0.7);

    // --- 2. RASTERIZATION (Collision Calculation) ---

    for (i, trigger) in triggers.iter_mut().enumerate().take(steps) {
        let hit_kick = kick_gon.hits(i, steps);
        let hit_snare = snare_gon.hits(i, steps);
        let hit_hat = hat_gon.hits(i, steps);
        let hit_bass = bass_gon.hits(i, steps);
        let hit_lead = lead_gon.hits(i, steps);

        // --- 3. CONFLICT RESOLUTION & VELOCITY ---

        if hit_kick {
            trigger.kick = true;
            trigger.velocity = kick_gon.velocity;
        }

        if hit_snare {
            trigger.snare = true;
            trigger.velocity = if hit_kick { 1.0 } else { snare_gon.velocity };
        }

        if hit_hat {
            let mask = (hit_kick || hit_snare) && density < 0.75;
            if !mask {
                trigger.hat = true;
                if !hit_kick && !hit_snare {
                    trigger.velocity = hat_gon.velocity;
                }
            }
        }

        if hit_bass {
            trigger.bass = true;
        }
        if hit_lead {
            trigger.lead = true;
        }
    }

    triggers
}

// --- ALGORITHME CLASSIC GROOVE ---
// Basé sur de vrais patterns de batterie musicaux
// Density contrôle la complexité rythmique
// Tension contrôle la syncopation et les ghost notes

/// NEW: Generates realistic drum patterns with time signature awareness
/// Restricts to 4/4, falls back to PerfectBalance for other signatures
#[must_use]
pub fn generate_classic_groove_with_time_sig(
    time_sig: TimeSignature,
    steps_per_measure: usize,
    density: f32,
    tension: f32,
) -> Vec<StepTrigger> {
    // ClassicGroove patterns are specifically designed for 4/4
    // For other time signatures, fallback to PerfectBalance
    if time_sig != TimeSignature::FOUR_FOUR {
        return generate_balanced_layers_with_time_sig(
            time_sig,
            steps_per_measure,
            density,
            tension,
            None,
        );
    }

    // Use legacy 4/4 implementation
    generate_classic_groove(steps_per_measure, density, tension)
}

/// DEPRECATED: Use generate_classic_groove_with_time_sig() for new code
/// Generates realistic drum patterns based on common grooves.
/// Uses density for kick complexity and tension for ghost notes/syncopation.
/// ONLY WORKS FOR 4/4 TIME
#[allow(clippy::too_many_lines)]
#[must_use]
pub fn generate_classic_groove(steps: usize, density: f32, tension: f32) -> Vec<StepTrigger> {
    let mut pattern = vec![StepTrigger::default(); steps];

    // === SUBDIVISIONS ===
    let beat = steps / 4; // Noire (12 pour 48, 24 pour 96)
    let eighth = beat / 2; // Croche
    let sixteenth = beat / 4; // Double-croche

    // === KICK PATTERNS ===
    // Basés sur des grooves réels de batterie
    match density {
        d if d < 0.25 => {
            // Half-time: Kick sur 1 seulement
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
        }
        d if d < 0.4 => {
            // Half-time avec 3: Kick sur 1 et 3
            for &pos in &[0, 2 * beat] {
                pattern[pos].kick = true;
                pattern[pos].velocity = 1.0;
            }
        }
        d if d < 0.6 => {
            // Four-on-the-floor classique
            for i in 0..4 {
                pattern[i * beat].kick = true;
                pattern[i * beat].velocity = if i == 0 { 1.0 } else { 0.85 };
            }
        }
        d if d < 0.8 => {
            // Groove avec anticipation: 1, 2-and, 3, 4
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
            pattern[beat + eighth].kick = true; // "2-and" (anticipation du 3)
            pattern[beat + eighth].velocity = 0.7;
            pattern[2 * beat].kick = true;
            pattern[2 * beat].velocity = 0.9;
            pattern[3 * beat].kick = true;
            pattern[3 * beat].velocity = 0.8;
        }
        _ => {
            // Breakbeat style: 1, 2-and, 3-e, 4
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
            pattern[beat + eighth].kick = true;
            pattern[beat + eighth].velocity = 0.75;
            if sixteenth > 0 {
                pattern[2 * beat + sixteenth].kick = true; // "3-e"
                pattern[2 * beat + sixteenth].velocity = 0.7;
            }
            pattern[3 * beat].kick = true;
            pattern[3 * beat].velocity = 0.85;
        }
    }

    // === SNARE PATTERNS ===
    // Toujours backbeat (2 et 4), avec ghost notes selon tension

    // Snares principales sur 2 et 4
    pattern[beat].snare = true;
    pattern[beat].velocity = 1.0;
    pattern[3 * beat].snare = true;
    pattern[3 * beat].velocity = 1.0;

    // Ghost notes selon tension
    if tension > 0.3 && sixteenth > 0 {
        // Ghost note avant le 2 (pickup)
        let ghost_pos = beat - sixteenth;
        if ghost_pos < steps {
            pattern[ghost_pos].snare = true;
            pattern[ghost_pos].velocity = 0.25;
        }
    }

    if tension > 0.5 && sixteenth > 0 {
        // Ghost note après le 2
        let ghost_pos = beat + sixteenth;
        pattern[ghost_pos].snare = true;
        pattern[ghost_pos].velocity = 0.3;

        // Ghost note avant le 4
        let ghost_pos2 = 3 * beat - sixteenth;
        if ghost_pos2 < steps {
            pattern[ghost_pos2].snare = true;
            pattern[ghost_pos2].velocity = 0.25;
        }
    }

    if tension > 0.7 && sixteenth > 0 {
        // Pattern de roulement: ghost notes sur les "e" et "a"
        // Sur le temps 3 pour créer du mouvement
        pattern[2 * beat + sixteenth].snare = true;
        pattern[2 * beat + sixteenth].velocity = 0.2;
        if sixteenth * 3 < beat {
            pattern[2 * beat + sixteenth * 3].snare = true;
            pattern[2 * beat + sixteenth * 3].velocity = 0.25;
        }
    }

    // === HI-HAT PATTERNS ===
    // Pattern régulier en croches ou doubles-croches selon density

    if density < 0.3 {
        // Sparse: juste les off-beats (croches "and")
        for i in 0..4 {
            let pos = i * beat + eighth;
            if pos < steps && !pattern[pos].kick && !pattern[pos].snare {
                pattern[pos].hat = true;
                pattern[pos].velocity = 0.5;
            }
        }
    } else if density < 0.6 {
        // Standard: croches régulières
        for i in 0..8 {
            let pos = i * eighth;
            if pos < steps {
                let on_beat = i % 2 == 0;
                // Skip si kick ou snare fort
                if pattern[pos].kick || (pattern[pos].snare && pattern[pos].velocity > 0.5) {
                    continue;
                }
                pattern[pos].hat = true;
                pattern[pos].velocity = if on_beat { 0.6 } else { 0.4 };
            }
        }
    } else {
        // Dense: doubles-croches avec accents
        if sixteenth > 0 {
            for i in 0..16 {
                let pos = i * sixteenth;
                if pos >= steps {
                    break;
                }

                // Skip si kick ou snare principal
                if pattern[pos].kick || (pattern[pos].snare && pattern[pos].velocity > 0.5) {
                    continue;
                }

                pattern[pos].hat = true;

                // Velocity pattern: accent sur les croches
                let is_eighth = i % 4 == 0;
                let is_sixteenth_and = i % 2 == 0;
                pattern[pos].velocity = if is_eighth {
                    0.65
                } else if is_sixteenth_and {
                    0.45
                } else {
                    0.3
                };
            }
        }
    }

    // Open hi-hat sur certaines positions selon tension
    if tension > 0.6 {
        // Accent fort sur le "and" du 4 pour transition
        let open_pos = 3 * beat + eighth;
        if open_pos < steps {
            pattern[open_pos].hat = true;
            pattern[open_pos].velocity = 0.8;
        }
    }

    // === BASS PATTERNS ===
    // Suivre le kick avec léger décalage ou remplissage
    for i in 0..steps {
        if pattern[i].kick {
            pattern[i].bass = true;
        } else if tension > 0.4 && i >= sixteenth && pattern[i - sixteenth].kick {
            // Syncopated bass after kick if high tension
            pattern[i].bass = true;
        }
    }

    // === LEAD PATTERNS ===
    // Mélodie simple sur division principale
    let melody_interval = if density < 0.4 { beat } else { eighth };
    for i in (0..steps).step_by(melody_interval) {
        // Lead on 1, 2-and, etc depending on tension
        let jitter = if tension > 0.5 && sixteenth > 0 { sixteenth } else { 0 };
        let final_pos = (i + jitter) % steps;
        pattern[final_pos].lead = true;
    }

    pattern
}

// ═══════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sequencer_bar_beat_tracking() {
        let mut seq = Sequencer::new_with_time_sig(
            TimeSignature::THREE_FOUR,
            4,
            3,
            120.0,
            RhythmMode::Euclidean,
        );

        // Initial state: Measure 1, Beat 1
        assert_eq!(seq.current_measure, 1);
        assert_eq!(seq.current_step, 0);
        assert_eq!(seq.current_beat_position(), (1, 0));

        // After 4 steps: Measure 1, Beat 2
        for _ in 0..4 {
            seq.tick();
        }
        assert_eq!(seq.current_measure, 1);
        assert_eq!(seq.current_beat_position(), (2, 0));

        // After 12 steps total (full 3/4 measure): Measure 2, Beat 1
        for _ in 0..8 {
            seq.tick();
        }
        assert_eq!(seq.current_measure, 2);
        assert_eq!(seq.current_step, 0);
        assert_eq!(seq.current_beat_position(), (1, 0));
    }

    #[test]
    fn test_sequencer_4_4_tracking() {
        let mut seq = Sequencer::new_with_time_sig(
            TimeSignature::FOUR_FOUR,
            4,
            4,
            120.0,
            RhythmMode::Euclidean,
        );

        assert_eq!(seq.steps_per_measure(), 16);
        assert_eq!(seq.current_measure, 1);

        // Tick through one measure
        for _ in 0..16 {
            seq.tick();
        }

        // Should be at measure 2 now
        assert_eq!(seq.current_measure, 2);
        assert_eq!(seq.current_step, 0);
    }

    #[test]
    fn test_sequencer_5_4_tracking() {
        let mut seq = Sequencer::new_with_time_sig(
            TimeSignature::FIVE_FOUR,
            4,
            5,
            120.0,
            RhythmMode::Euclidean,
        );

        assert_eq!(seq.steps_per_measure(), 20);

        // Tick through one measure
        for i in 0..20 {
            let (beat, _) = seq.current_beat_position();
            // Verify beats are 1-5
            assert!(beat >= 1 && beat <= 5, "Beat {} at step {}", beat, i);
            seq.tick();
        }

        // Should be at measure 2
        assert_eq!(seq.current_measure, 2);
        assert_eq!(seq.current_step, 0);
    }

    #[test]
    fn test_sequencer_beat_position_calculation() {
        let seq = Sequencer::new_with_time_sig(
            TimeSignature::FOUR_FOUR,
            4,
            4,
            120.0,
            RhythmMode::Euclidean,
        );

        // 4/4 with 4 steps per quarter = 4 steps per beat
        // Step 0 = Beat 1, Step 0
        assert_eq!(seq.current_beat_position(), (1, 0));

        // Create another seq at different positions
        let mut seq2 = seq.clone();
        seq2.current_step = 4;
        assert_eq!(seq2.current_beat_position(), (2, 0)); // Beat 2

        seq2.current_step = 8;
        assert_eq!(seq2.current_beat_position(), (3, 0)); // Beat 3

        seq2.current_step = 12;
        assert_eq!(seq2.current_beat_position(), (4, 0)); // Beat 4
    }

    #[test]
    fn test_backward_compat_legacy_constructor() {
        // Old way should still work
        let seq = Sequencer::new(16, 4, 120.0);

        // Should infer 4/4
        assert_eq!(seq.time_signature, TimeSignature::FOUR_FOUR);
        assert_eq!(seq.steps_per_quarter, 4);
        assert_eq!(seq.steps_per_measure(), 16);
        assert_eq!(seq.current_measure, 1);

        // Deprecated steps field should match
        assert_eq!(seq.steps, 16);
    }

    #[test]
    fn test_backward_compat_3_4_inference() {
        let seq = Sequencer::new(12, 3, 120.0);

        // Should infer 3/4
        assert_eq!(seq.time_signature, TimeSignature::THREE_FOUR);
        assert_eq!(seq.steps_per_measure(), 12);
    }

    #[test]
    fn test_backward_compat_6_8_inference() {
        let seq = Sequencer::new(24, 6, 120.0);

        // Should infer 6/8
        assert_eq!(seq.time_signature, TimeSignature::SIX_EIGHT);
        assert_eq!(seq.steps_per_measure(), 12); // 6 eighths = 3 quarters
    }

    // ═══════════════════════════════════════════════════════════════════
    // PERFECT BALANCE TESTS
    // ═══════════════════════════════════════════════════════════════════

    #[test]
    fn test_perfect_balance_3_4() {
        let pattern =
            generate_balanced_layers_with_time_sig(TimeSignature::THREE_FOUR, 12, 0.5, 0.3, None);

        assert_eq!(pattern.len(), 12);

        // In 3/4 with medium density, should have 3 kick hits (one per beat)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 3, "3/4 should have 3 kicks");
    }

    #[test]
    fn test_perfect_balance_4_4() {
        let pattern =
            generate_balanced_layers_with_time_sig(TimeSignature::FOUR_FOUR, 16, 0.5, 0.3, None);

        assert_eq!(pattern.len(), 16);

        // In 4/4 with medium density, should have 4 kick hits (one per beat)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 4, "4/4 should have 4 kicks");
    }

    #[test]
    fn test_perfect_balance_5_4() {
        let pattern =
            generate_balanced_layers_with_time_sig(TimeSignature::FIVE_FOUR, 20, 0.5, 0.3, None);

        assert_eq!(pattern.len(), 20);

        // In 5/4 with medium density, should have 5 kick hits (one per beat)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 5, "5/4 should have 5 kicks");
    }

    #[test]
    fn test_perfect_balance_7_8() {
        let pattern = generate_balanced_layers_with_time_sig(
            TimeSignature::SEVEN_EIGHT,
            14, // 7 eighths ≈ 3.5 quarters, with 4 steps per quarter = 14
            0.5,
            0.3,
            None,
        );

        assert_eq!(pattern.len(), 14);

        // Should still generate valid pattern
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert!(kick_count > 0, "7/8 should have kicks");
    }

    #[test]
    fn test_perfect_balance_low_density() {
        let pattern = generate_balanced_layers_with_time_sig(
            TimeSignature::FOUR_FOUR,
            16,
            0.2, // Low density
            0.3,
            None,
        );

        // Low density should have only 1 kick (downbeat only)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 1, "Low density should have 1 kick");
    }

    #[test]
    fn test_perfect_balance_high_density() {
        let pattern = generate_balanced_layers_with_time_sig(
            TimeSignature::FOUR_FOUR,
            16,
            0.8, // High density
            0.3,
            None,
        );

        // High density should have 8 kicks (beats + subdivisions)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 8, "High density should have 8 kicks");
    }

    // ═══════════════════════════════════════════════════════════════════
    // CLASSIC GROOVE TESTS
    // ═══════════════════════════════════════════════════════════════════

    #[test]
    fn test_classic_groove_4_4_works() {
        let pattern = generate_classic_groove_with_time_sig(TimeSignature::FOUR_FOUR, 16, 0.5, 0.3);

        assert_eq!(pattern.len(), 16);

        // Should have kicks and snares (realistic drum pattern)
        let kick_count = pattern.iter().filter(|t| t.kick).count();
        let snare_count = pattern.iter().filter(|t| t.snare).count();

        assert!(kick_count > 0, "4/4 ClassicGroove should have kicks");
        assert!(snare_count > 0, "4/4 ClassicGroove should have snares");
    }

    #[test]
    fn test_classic_groove_non_4_4_fallback() {
        // 3/4 should fallback to PerfectBalance
        let pattern_3_4 =
            generate_classic_groove_with_time_sig(TimeSignature::THREE_FOUR, 12, 0.5, 0.3);

        assert_eq!(pattern_3_4.len(), 12);
        let kick_count = pattern_3_4.iter().filter(|t| t.kick).count();
        // PerfectBalance with 3/4 should give 3 kicks
        assert_eq!(kick_count, 3, "3/4 should fallback to PerfectBalance with 3 kicks");
    }

    #[test]
    fn test_classic_groove_5_4_fallback() {
        // 5/4 should fallback to PerfectBalance
        let pattern_5_4 =
            generate_classic_groove_with_time_sig(TimeSignature::FIVE_FOUR, 20, 0.5, 0.3);

        assert_eq!(pattern_5_4.len(), 20);
        let kick_count = pattern_5_4.iter().filter(|t| t.kick).count();
        // PerfectBalance with 5/4 should give 5 kicks
        assert_eq!(kick_count, 5, "5/4 should fallback to PerfectBalance with 5 kicks");
    }

    #[test]
    fn test_sequencer_classic_groove_mode() {
        // Test that sequencer with ClassicGroove mode works
        let mut seq = Sequencer::new_with_time_sig(
            TimeSignature::FOUR_FOUR,
            4,
            4,
            120.0,
            RhythmMode::ClassicGroove,
        );

        // Pattern should be generated
        assert!(!seq.pattern.is_empty());
        assert_eq!(seq.pattern.len(), 16);

        // Should have some hits
        let has_hits = seq.pattern.iter().any(|t| t.is_any());
        assert!(has_hits, "ClassicGroove pattern should have hits");
    }

    #[test]
    fn test_sequencer_classic_groove_fallback_3_4() {
        // Test that sequencer with 3/4 + ClassicGroove falls back to PerfectBalance
        let mut seq = Sequencer::new_with_time_sig(
            TimeSignature::THREE_FOUR,
            4,
            3,
            120.0,
            RhythmMode::ClassicGroove,
        );

        assert_eq!(seq.pattern.len(), 12);

        // Should have 3 kicks (PerfectBalance behavior)
        let kick_count = seq.pattern.iter().filter(|t| t.kick).count();
        assert_eq!(kick_count, 3, "3/4 ClassicGroove should fallback to 3 kicks");
    }
}
