use serde::{Serialize, Deserialize};
use bevy_reflect::Reflect;

// --- RHYTHM MODE (Strategy Pattern) ---

#[derive(Clone, Copy, Debug, PartialEq, Default, Serialize, Deserialize, Reflect)]
pub enum RhythmMode {
    #[default]
    Euclidean,      // Algorithme de Bjorklund (Classique)
    PerfectBalance, // Algorithme Additif (XronoMorph style) - Polygones réguliers
    ClassicGroove,  // Patterns de batterie réalistes (ghost notes, grooves)
}

/// Événement déclenché à chaque step du séquenceur
/// Indique quelles voix doivent jouer
#[derive(Clone, Copy, Debug, Default)]
pub struct StepTrigger {
    pub kick: bool,     // Fondation (Square/Octagon)
    pub snare: bool,    // Tension (Triangle/Backbeat)
    pub hat: bool,      // Remplissage (Euclidean Fills)
    pub bass: bool,     // NEW: Harmonie Basse (Channel 0)
    pub lead: bool,     // NEW: Mélodie (Channel 1)
    pub velocity: f32,  // Dynamique générale (0.0 à 1.0)
}

impl StepTrigger {
    pub fn is_any(&self) -> bool {
        self.kick || self.snare || self.hat || self.bass || self.lead
    }
}

// --- POLYGON (Perfect Balance Primitive) ---

/// Represents a regular polygon inscribed in the time cycle.
/// This is the atomic unit of the "Perfect Balance" algorithm.
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub struct Polygon {
    /// Number of vertices (e.g., 3 = Triangle, 4 = Square).
    /// Ideally should be a divisor of the total steps for perfect alignment.
    pub vertices: usize,

    /// Rotation in steps (Phase shift).
    /// Determines where the polygon starts on the circle.
    pub rotation_offset: usize,

    /// Velocity (Amplitude) of events generated by this polygon.
    pub velocity: f32,
}

impl Polygon {
    /// Standard constructor
    pub fn new(vertices: usize, rotation_offset: usize, velocity: f32) -> Self {
        Self { vertices, rotation_offset, velocity }
    }

    /// Checks if this polygon has an active vertex at the given step.
    /// Uses a fast path when total_steps is divisible by vertices,
    /// and falls back to a Euclidean rhythm algorithm for non-divisible cases.
    pub fn hits(&self, step: usize, total_steps: usize) -> bool {
        if self.vertices == 0 || total_steps == 0 { return false; }
        // If vertices are more than total_steps, it's not meaningful to have hits in a polygon context.
        // This also prevents the Euclidean algorithm from always returning true.
        if self.vertices > total_steps { return false; }

        let adjusted_step = (step + total_steps - (self.rotation_offset % total_steps)) % total_steps;

        if total_steps % self.vertices == 0 {
            // Fast path for when vertices is a divisor of total_steps.
            let interval = total_steps / self.vertices;
            // interval cannot be 0 here because we already checked self.vertices > total_steps
            // and total_steps is not 0.
            adjusted_step % interval == 0
        } else {
            // Fallback for non-divisors, generates a Euclidean rhythm.
            let prev_adjusted_step = (adjusted_step + total_steps - 1) % total_steps;
            (adjusted_step * self.vertices) / total_steps != (prev_adjusted_step * self.vertices) / total_steps
        }
    }
}

// --- SEQUENCER STRUCT ---

pub struct Sequencer {
    pub steps: usize,
    pub pulses: usize,
    pub pattern: Vec<StepTrigger>, // Remplacement de Vec<bool>
    pub rotation: usize,
    pub current_step: usize,
    pub bpm: f32,
    pub last_tick_time: f64,
    pub mode: RhythmMode,
    pub tension: f32,
    pub density: f32,
}

impl Sequencer {
    pub fn new(steps: usize, pulses: usize, bpm: f32) -> Self {
        Self::new_with_mode(steps, pulses, bpm, RhythmMode::Euclidean)
    }

    pub fn new_with_mode(steps: usize, pulses: usize, bpm: f32, mode: RhythmMode) -> Self {
        let mut seq = Sequencer {
            steps,
            pulses,
            pattern: vec![StepTrigger::default(); steps],
            rotation: 0,
            current_step: 0,
            bpm,
            last_tick_time: 0.0,
            mode,
            tension: 0.0,
            density: 0.5,
        };
        seq.regenerate_pattern();
        seq
    }

    pub fn new_with_rotation(steps: usize, pulses: usize, bpm: f32, rotation: usize) -> Self {
        let mut seq = Self::new(steps, pulses, bpm);
        seq.set_rotation(rotation);
        seq
    }

    pub fn set_rotation(&mut self, offset: usize) {
        self.rotation = offset % self.steps;
        // On régénère simplement pour appliquer la rotation
        // (Optimisation possible : rotation in-place, mais régénérer est plus sûr ici)
        self.regenerate_pattern();
    }

    pub fn regenerate_pattern(&mut self) {
        let mut raw = match self.mode {
            RhythmMode::Euclidean => {
                // Mode classique : On map le booléen sur Kick + Hat
                let bools = generate_euclidean_bools(self.steps, self.pulses);
                bools.into_iter().map(|b| StepTrigger {
                    kick: b,
                    snare: false,
                    hat: b, // Layering simple
                    bass: b, // Sync bass with kick in Euclidean mode
                    lead: false,
                    velocity: if b { 1.0 } else { 0.0 },
                }).collect()
            }
            RhythmMode::PerfectBalance => {
                // Mode XronoMorph : Polygones réguliers superposés
                generate_balanced_layers_48(self.steps, self.density, self.tension)
            }
            RhythmMode::ClassicGroove => {
                // Mode groove réaliste : Patterns de batterie avec ghost notes
                generate_classic_groove(self.steps, self.density, self.tension)
            }
        };

        // Appliquer la rotation (safe: handle edge cases)
        let raw_len = raw.len();
        if self.rotation > 0 && raw_len > 0 {
            let safe_rotation = self.rotation % raw_len;
            if safe_rotation > 0 {
                raw.rotate_left(raw_len - safe_rotation);
            }
        }

        self.pattern = raw;
    }

    /// Upgrade to a specific number of steps (48, 96, etc.)
    pub fn upgrade_to_steps(&mut self, new_steps: usize) {
        if self.steps != new_steps && new_steps > 0 {
            self.steps = new_steps;
            self.current_step = 0;
            // Clamp rotation to new step count to prevent overflow in regenerate_pattern
            self.rotation = self.rotation % new_steps;
            self.pattern = vec![StepTrigger::default(); new_steps];
            self.regenerate_pattern();
        }
    }

    /// Legacy: upgrade to 48 steps
    pub fn upgrade_to_48_steps(&mut self) {
        self.upgrade_to_steps(48);
    }

    pub fn tick(&mut self) -> StepTrigger {
        if self.pattern.is_empty() {
            return StepTrigger::default();
        }
        // Safety: clamp current_step to pattern bounds (can become invalid if steps changed)
        if self.current_step >= self.pattern.len() {
            self.current_step = 0;
        }
        let trigger = self.pattern[self.current_step];
        self.current_step = (self.current_step + 1) % self.pattern.len();
        trigger
    }
}

/// Génère les booléens de Bjorklund (Legacy)
pub fn generate_euclidean_bools(steps: usize, pulses: usize) -> Vec<bool> {
    if pulses == 0 { return vec![false; steps]; }
    if pulses >= steps { return vec![true; steps]; }

    let mut pattern: Vec<Vec<u8>> = Vec::new();
    for _ in 0..pulses { pattern.push(vec![1]); }
    for _ in 0..(steps - pulses) { pattern.push(vec![0]); }

    let mut count = std::cmp::min(pulses, steps - pulses);
    let mut remainder = pattern.len() - count;

    while remainder > 1 && count > 0 {
        for i in 0..count {
            let last = pattern.pop().unwrap();
            pattern[i].extend(last);
        }
        remainder = pattern.len() - count;
        count = std::cmp::min(count, remainder);
    }

    let mut result = Vec::new();
    for group in pattern {
        for val in group {
            result.push(val == 1);
        }
    }
    result
}

// --- ALGORITHME PERFECT BALANCE / WELL-FORMED ---
// Based on XronoMorph theory: superposition of regular polygons
// Density controls polygon complexity (number of vertices)
// Tension controls phase shift (rotation) for syncopation

/// Generates a pattern based on the superposition of regular polygons.
/// Respects the Perfect Balance theorem (sum of vectors is zero).
pub fn generate_balanced_layers_48(steps: usize, density: f32, tension: f32) -> Vec<StepTrigger> {
    let mut triggers = vec![StepTrigger::default(); steps];

    // --- 1. LAYER CONFIGURATION ---

    // LAYER A: KICK (Foundation)
    // Uses stable (even) shapes
    let kick_gon = if density < 0.3 {
        // Low density: Digon (on 1 and 25 for 48 steps)
        Polygon::new(2, 0, 1.0)
    } else {
        // Standard density: Square (Four-on-the-floor)
        Polygon::new(4, 0, 1.0)
    };

    // LAYER B: SNARE (Counterpoint)
    // Uses odd shapes to create polyrhythm (e.g., 4 against 3)
    // OR shapes shifted by tension.
    let snare_vertices = if density < 0.5 { 3 } else { 6 }; // Triangle or Hexagon

    // Tension controls Snare rotation relative to Kick.
    // Tension 0.0 = Aligned. Tension 0.5 = Pure shift (off-beat).
    // On 48 steps, a full shift = steps / vertices.
    let max_snare_shift = steps / snare_vertices;
    // Using simple casting for integer arithmetic on grid
    let snare_offset = (tension * max_snare_shift as f32) as usize;

    let snare_gon = Polygon::new(snare_vertices, snare_offset, 0.9);

    // LAYER C: HI-HAT (Fill)
    // High frequency shapes.
    let hat_vertices = if density < 0.25 {
        6  // Triplet eighths
    } else if density < 0.6 {
        8  // Straight eighths
    } else if density < 0.85 {
        12 // Sixteenths
    } else {
        16 // Fast polyrhythm (fast 4:3)
    };

    // The Hat often "floats" around the beat to create groove.
    // Use tension to slightly shift the Hat (Mathematical Swing).
    let hat_offset = if tension > 0.3 {
        (tension * (steps / hat_vertices) as f32 * 0.5) as usize
    } else {
        0
    };

    let hat_gon = Polygon::new(hat_vertices, hat_offset, 0.6 * density.max(0.5));

    // LAYER D: BASS (Harmonic Foundation)
    let bass_gon = if density < 0.4 { kick_gon } else { Polygon::new(8, 0, 0.8) };

    // LAYER E: LEAD (Melody)
    let lead_vertices = if density < 0.3 { 3 } else { 5 };
    let lead_offset = (tension * (steps / lead_vertices) as f32) as usize;
    let lead_gon = Polygon::new(lead_vertices, lead_offset, 0.7);

    // --- 2. RASTERIZATION (Collision Calculation) ---

    for i in 0..steps {
        let hit_kick = kick_gon.hits(i, steps);
        let hit_snare = snare_gon.hits(i, steps);
        let hit_hat = hat_gon.hits(i, steps);
        let hit_bass = bass_gon.hits(i, steps);
        let hit_lead = lead_gon.hits(i, steps);

        // --- 3. CONFLICT RESOLUTION & VELOCITY ---

        if hit_kick {
            triggers[i].kick = true;
            triggers[i].velocity = kick_gon.velocity;
        }

        if hit_snare {
            triggers[i].snare = true;
            // If snare hits same time as kick, accentuate it
            triggers[i].velocity = if hit_kick { 1.0 } else { snare_gon.velocity };
        }

        if hit_hat {
            // Masking logic: Don't necessarily play HH if Kick or Snare plays
            // Unless density is very high (Wall of sound)
            let mask = (hit_kick || hit_snare) && density < 0.75;

            if !mask {
                triggers[i].hat = true;
                // If it's the only element, apply its velocity
                if !hit_kick && !hit_snare {
                    triggers[i].velocity = hat_gon.velocity;
                }
            }
        }

        if hit_bass { triggers[i].bass = true; }
        if hit_lead { triggers[i].lead = true; }
    }

    triggers
}

// --- ALGORITHME CLASSIC GROOVE ---
// Basé sur de vrais patterns de batterie musicaux
// Density contrôle la complexité rythmique
// Tension contrôle la syncopation et les ghost notes

/// Generates realistic drum patterns based on common grooves.
/// Uses density for kick complexity and tension for ghost notes/syncopation.
pub fn generate_classic_groove(steps: usize, density: f32, tension: f32) -> Vec<StepTrigger> {
    let mut pattern = vec![StepTrigger::default(); steps];

    // === SUBDIVISIONS ===
    let beat = steps / 4;           // Noire (12 pour 48, 24 pour 96)
    let eighth = beat / 2;          // Croche
    let sixteenth = beat / 4;       // Double-croche

    // === KICK PATTERNS ===
    // Basés sur des grooves réels de batterie
    match density {
        d if d < 0.25 => {
            // Half-time: Kick sur 1 seulement
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
        }
        d if d < 0.4 => {
            // Half-time avec 3: Kick sur 1 et 3
            for &pos in &[0, 2 * beat] {
                pattern[pos].kick = true;
                pattern[pos].velocity = 1.0;
            }
        }
        d if d < 0.6 => {
            // Four-on-the-floor classique
            for i in 0..4 {
                pattern[i * beat].kick = true;
                pattern[i * beat].velocity = if i == 0 { 1.0 } else { 0.85 };
            }
        }
        d if d < 0.8 => {
            // Groove avec anticipation: 1, 2-and, 3, 4
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
            pattern[beat + eighth].kick = true;  // "2-and" (anticipation du 3)
            pattern[beat + eighth].velocity = 0.7;
            pattern[2 * beat].kick = true;
            pattern[2 * beat].velocity = 0.9;
            pattern[3 * beat].kick = true;
            pattern[3 * beat].velocity = 0.8;
        }
        _ => {
            // Breakbeat style: 1, 2-and, 3-e, 4
            pattern[0].kick = true;
            pattern[0].velocity = 1.0;
            pattern[beat + eighth].kick = true;
            pattern[beat + eighth].velocity = 0.75;
            if sixteenth > 0 {
                pattern[2 * beat + sixteenth].kick = true;  // "3-e"
                pattern[2 * beat + sixteenth].velocity = 0.7;
            }
            pattern[3 * beat].kick = true;
            pattern[3 * beat].velocity = 0.85;
        }
    }

    // === SNARE PATTERNS ===
    // Toujours backbeat (2 et 4), avec ghost notes selon tension

    // Snares principales sur 2 et 4
    pattern[beat].snare = true;
    pattern[beat].velocity = 1.0;
    pattern[3 * beat].snare = true;
    pattern[3 * beat].velocity = 1.0;

    // Ghost notes selon tension
    if tension > 0.3 && sixteenth > 0 {
        // Ghost note avant le 2 (pickup)
        let ghost_pos = beat - sixteenth;
        if ghost_pos < steps {
            pattern[ghost_pos].snare = true;
            pattern[ghost_pos].velocity = 0.25;
        }
    }

    if tension > 0.5 && sixteenth > 0 {
        // Ghost note après le 2
        let ghost_pos = beat + sixteenth;
        pattern[ghost_pos].snare = true;
        pattern[ghost_pos].velocity = 0.3;

        // Ghost note avant le 4
        let ghost_pos2 = 3 * beat - sixteenth;
        if ghost_pos2 < steps {
            pattern[ghost_pos2].snare = true;
            pattern[ghost_pos2].velocity = 0.25;
        }
    }

    if tension > 0.7 && sixteenth > 0 {
        // Pattern de roulement: ghost notes sur les "e" et "a"
        // Sur le temps 3 pour créer du mouvement
        pattern[2 * beat + sixteenth].snare = true;
        pattern[2 * beat + sixteenth].velocity = 0.2;
        if sixteenth * 3 < beat {
            pattern[2 * beat + sixteenth * 3].snare = true;
            pattern[2 * beat + sixteenth * 3].velocity = 0.25;
        }
    }

    // === HI-HAT PATTERNS ===
    // Pattern régulier en croches ou doubles-croches selon density

    if density < 0.3 {
        // Sparse: juste les off-beats (croches "and")
        for i in 0..4 {
            let pos = i * beat + eighth;
            if pos < steps && !pattern[pos].kick && !pattern[pos].snare {
                pattern[pos].hat = true;
                pattern[pos].velocity = 0.5;
            }
        }
    } else if density < 0.6 {
        // Standard: croches régulières
        for i in 0..8 {
            let pos = i * eighth;
            if pos < steps {
                let on_beat = i % 2 == 0;
                // Skip si kick ou snare fort
                if pattern[pos].kick || (pattern[pos].snare && pattern[pos].velocity > 0.5) {
                    continue;
                }
                pattern[pos].hat = true;
                pattern[pos].velocity = if on_beat { 0.6 } else { 0.4 };
            }
        }
    } else {
        // Dense: doubles-croches avec accents
        if sixteenth > 0 {
            for i in 0..16 {
                let pos = i * sixteenth;
                if pos >= steps { break; }

                // Skip si kick ou snare principal
                if pattern[pos].kick || (pattern[pos].snare && pattern[pos].velocity > 0.5) {
                    continue;
                }

                pattern[pos].hat = true;

                // Velocity pattern: accent sur les croches
                let is_eighth = i % 4 == 0;
                let is_sixteenth_and = i % 2 == 0;
                pattern[pos].velocity = if is_eighth {
                    0.65
                } else if is_sixteenth_and {
                    0.45
                } else {
                    0.3
                };
            }
        }
    }

    // Open hi-hat sur certaines positions selon tension
    if tension > 0.6 {
        // Accent fort sur le "and" du 4 pour transition
        let open_pos = 3 * beat + eighth;
        if open_pos < steps {
            pattern[open_pos].hat = true;
            pattern[open_pos].velocity = 0.8;
        }
    }

    // === BASS PATTERNS ===
    // Suivre le kick avec léger décalage ou remplissage
    for i in 0..steps {
        if pattern[i].kick {
            pattern[i].bass = true;
        } else if tension > 0.4 && i >= sixteenth && pattern[i-sixteenth].kick {
             // Syncopated bass after kick if high tension
             pattern[i].bass = true;
        }
    }
    
    // === LEAD PATTERNS ===
    // Mélodie simple sur division principale
    let melody_interval = if density < 0.4 { beat } else { eighth };
    for i in (0..steps).step_by(melody_interval) {
        // Lead on 1, 2-and, etc depending on tension
        let jitter = if tension > 0.5 && sixteenth > 0 { sixteenth } else { 0 };
        let final_pos = (i + jitter) % steps;
        pattern[final_pos].lead = true;
    }

    pattern
}
