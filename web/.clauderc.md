# HARMONIUM PROJECT RULES

## Tech Stack

- Framework: SvelteKit with Svelte 5 (Runes Mode ONLY)
- Styling: Tailwind CSS 4
- Language: TypeScript

## Critical Rules

### 1. Svelte 5 Runes Only

- **NEVER** use `export let` for props. Use `let { prop } = $props();`
- **NEVER** use `$:` for reactivity. Use `$derived()` or `$effect()`
- **NEVER** use top-level `let` for state. Use `let x = $state(0);`
- **ALWAYS** use `$props<TypeHere>()` with TypeScript types

### 2. Bridge Pattern

- UI components must NOT contain audio logic
- All audio/engine commands must go through `bridge.doSomething()`
- UI reflects `engineState` (from stores), it does not store its own truth

### 3. Component Patterns

#### Props (replacing `export let`)

```typescript
// ❌ WRONG (Svelte 4)
export let bridge: HarmoniumBridge;
export let state: EngineState;

// ✅ CORRECT (Svelte 5)
let { bridge, state } = $props<{
	bridge: HarmoniumBridge;
	state: EngineState;
}>();
```

#### Reactive Statements (replacing `$:`)

```typescript
// ❌ WRONG (Svelte 4)
$: computedValue = someValue * 2;

// ✅ CORRECT (Svelte 5)
let computedValue = $derived(someValue * 2);
```

#### Side Effects (replacing `$:` blocks)

```typescript
// ❌ WRONG (Svelte 4)
$: if (condition) {
	doSomething();
}

// ✅ CORRECT (Svelte 5)
$effect(() => {
	if (condition) {
		doSomething();
	}
});
```

#### Local State

```typescript
// ❌ WRONG (Svelte 4)
let count = 0;

// ✅ CORRECT (Svelte 5)
let count = $state(0);
```

### 4. MCP Usage

- Use `svelte-autofixer` after writing any Svelte component to verify syntax
- Use MCP to fetch latest Svelte 5 documentation before making changes

## Migration Checklist

When migrating a component from Svelte 4 to Svelte 5:

1. Replace all `export let` with `$props()` destructuring
2. Replace all `$:` reactive statements with `$derived()` or `$effect()`
3. Wrap mutable state with `$state()`
4. Add TypeScript types to `$props<>()`
5. Test the component
6. Run svelte-check to verify

## Additional Guidelines

- Keep components focused and single-purpose
- Prefer composition over large monolithic components
- Use TypeScript for all new code
- Follow existing naming conventions
